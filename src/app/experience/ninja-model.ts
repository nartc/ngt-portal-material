/**Auto-generated by: https://github.com/angular-threejs/gltf
Command: npx angular-three-gltf&#64;1.0.16 public/Ninja.gltf -o src/app/experience/ninja-model.ts --selector app-ninja-model --name NinjaModel --transform
**/

import {
  ChangeDetectionStrategy,
  Component,
  computed,
  CUSTOM_ELEMENTS_SCHEMA,
  effect,
  ElementRef,
  inject,
  input,
  model,
  signal,
  Signal,
  viewChild,
} from '@angular/core';
import { extend, NgtArgs, NgtGroup, NgtObjectEvents } from 'angular-three';
import { injectGLTF } from 'angular-three-soba/loaders';
import { injectAnimations, NgtsAnimationApi, NgtsAnimationClips } from 'angular-three-soba/misc';
import type * as THREE from 'three';
import { Group, SkinnedMesh } from 'three';
import { GLTF } from 'three-stdlib';
import { injectModelAnimation } from './model-animation';

type ActionName =
  | 'Death'
  | 'Duck'
  | 'HitReact'
  | 'Idle'
  | 'Jump'
  | 'Jump_Idle'
  | 'Jump_Land'
  | 'No'
  | 'Punch'
  | 'Run'
  | 'Walk'
  | 'Wave'
  | 'Weapon'
  | 'Yes';
type NinjaModelAnimationClips = NgtsAnimationClips<ActionName>;
export type NinjaModelAnimationApi = NgtsAnimationApi<NinjaModelAnimationClips> | null;
export type NinjaModelGLTFResult = GLTF & {
  animations: NinjaModelAnimationClips[];
  nodes: {
    Ninja: THREE.SkinnedMesh;
    Root: THREE.Bone;
  };
  materials: {
    Atlas: THREE.MeshStandardMaterial;
  };
};

@Component({
  selector: 'app-ninja-model',
  standalone: true,
  template: `
    @if (gltf(); as gltf) {
      <ngt-group #model [parameters]="options()" (pointerover)="hovered.set(true)" (pointerout)="hovered.set(false)">
        <ngt-group name="Scene">
          <ngt-group name="CharacterArmature">
            <ngt-primitive *args="[gltf.nodes.Root]" />
            <ngt-skinned-mesh
              name="Ninja"
              [geometry]="gltf.nodes.Ninja.geometry"
              [material]="gltf.materials.Atlas"
              [skeleton]="gltf.nodes.Ninja.skeleton"
            />
          </ngt-group>
        </ngt-group>

        <ng-content />
      </ngt-group>
    }
  `,
  imports: [NgtArgs],
  hostDirectives: [
    {
      directive: NgtObjectEvents,
      outputs: [
        'click',
        'dblclick',
        'contextmenu',
        'pointerup',
        'pointerdown',
        'pointerover',
        'pointerout',
        'pointerenter',
        'pointerleave',
        'pointermove',
        'pointermissed',
        'pointercancel',
        'wheel',
      ],
    },
  ],
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class NinjaModel {
  protected readonly Math = Math;

  options = input({} as Partial<NgtGroup>);
  animations = model<NinjaModelAnimationApi>();
  modelRef = viewChild<ElementRef<Group>>('model');

  protected gltf = injectGLTF(() => '/Ninja-transformed.glb', {
    useDraco: true,
  }) as unknown as Signal<NinjaModelGLTFResult | null>;
  protected hovered = signal(false);

  private scene = computed(() => {
    const gltf = this.gltf();
    if (!gltf) return null;
    return gltf.scene;
  });

  private objectEvents = inject(NgtObjectEvents, { host: true });

  constructor() {
    extend({ Group, SkinnedMesh });

    injectModelAnimation(this.hovered, this.animations, 'Idle', 'Wave');

    const animations = injectAnimations(this.gltf, this.scene);
    effect(
      () => {
        if (animations.ready()) {
          this.animations.set(animations);
        }
      },
      { allowSignalWrites: true },
    );

    effect(
      () => {
        const modelRef = this.modelRef()?.nativeElement;
        if (!modelRef) return;

        this.objectEvents.ngtObjectEvents.set(modelRef);
      },
      { allowSignalWrites: true },
    );
  }
}
