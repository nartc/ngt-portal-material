/**Auto-generated by: https://github.com/angular-threejs/gltf
Command: npx angular-three-gltf&#64;1.0.16 public/Ghost_Skull.gltf -o src/app/experience/ghost-skull-model.ts --selector app-ghost-skull-model --name GhostSkullModel --transform
**/

import {
  ChangeDetectionStrategy,
  Component,
  computed,
  CUSTOM_ELEMENTS_SCHEMA,
  effect,
  ElementRef,
  inject,
  input,
  model,
  signal,
  Signal,
  viewChild,
} from '@angular/core';
import { extend, NgtArgs, NgtGroup, NgtObjectEvents } from 'angular-three';
import { injectGLTF } from 'angular-three-soba/loaders';
import { injectAnimations, NgtsAnimationApi, NgtsAnimationClips } from 'angular-three-soba/misc';
import type * as THREE from 'three';
import { Group, SkinnedMesh } from 'three';
import { GLTF } from 'three-stdlib';
import { injectModelAnimation } from './model-animation';

type ActionName = 'Death' | 'Fast_Flying' | 'Flying_Idle' | 'Headbutt' | 'HitReact' | 'No' | 'Punch' | 'Yes';
type GhostSkullModelAnimationClips = NgtsAnimationClips<ActionName>;
export type GhostSkullModelAnimationApi = NgtsAnimationApi<GhostSkullModelAnimationClips> | null;
export type GhostSkullModelGLTFResult = GLTF & {
  animations: GhostSkullModelAnimationClips[];
  nodes: {
    Ghost_Skull: THREE.SkinnedMesh;
    Root: THREE.Bone;
  };
  materials: {
    Atlas: THREE.MeshStandardMaterial;
  };
};

@Component({
  selector: 'app-ghost-skull-model',
  standalone: true,
  template: `
    @if (gltf(); as gltf) {
      <ngt-group #model [parameters]="options()" (pointerover)="hovered.set(true)" (pointerout)="hovered.set(false)">
        <ngt-group name="Scene">
          <ngt-group name="CharacterArmature">
            <ngt-primitive *args="[gltf.nodes.Root]" />
            <ngt-skinned-mesh
              name="Ghost_Skull"
              [geometry]="gltf.nodes.Ghost_Skull.geometry"
              [material]="gltf.materials.Atlas"
              [skeleton]="gltf.nodes.Ghost_Skull.skeleton"
            />
          </ngt-group>
        </ngt-group>

        <ng-content />
      </ngt-group>
    }
  `,
  imports: [NgtArgs],
  hostDirectives: [
    {
      directive: NgtObjectEvents,
      outputs: [
        'click',
        'dblclick',
        'contextmenu',
        'pointerup',
        'pointerdown',
        'pointerover',
        'pointerout',
        'pointerenter',
        'pointerleave',
        'pointermove',
        'pointermissed',
        'pointercancel',
        'wheel',
      ],
    },
  ],
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class GhostSkullModel {
  protected readonly Math = Math;

  options = input({} as Partial<NgtGroup>);
  animations = model<GhostSkullModelAnimationApi>();
  modelRef = viewChild<ElementRef<Group>>('model');

  protected gltf = injectGLTF(() => '/Ghost_Skull-transformed.glb', {
    useDraco: true,
  }) as unknown as Signal<GhostSkullModelGLTFResult | null>;

  protected hovered = signal(false);

  private scene = computed(() => {
    const gltf = this.gltf();
    if (!gltf) return null;
    return gltf.scene;
  });

  private objectEvents = inject(NgtObjectEvents, { host: true });

  constructor() {
    extend({ Group, SkinnedMesh });

    injectModelAnimation(this.hovered, this.animations, 'Flying_Idle', 'Fast_Flying');

    const animations = injectAnimations(this.gltf, this.scene);
    effect(
      () => {
        if (animations.ready()) {
          this.animations.set(animations);
        }
      },
      { allowSignalWrites: true },
    );

    effect(
      () => {
        const modelRef = this.modelRef()?.nativeElement;
        if (!modelRef) return;

        this.objectEvents.ngtObjectEvents.set(modelRef);
      },
      { allowSignalWrites: true },
    );
  }
}
